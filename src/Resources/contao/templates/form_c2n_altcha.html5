<?php
// File: vendor/con2net/contao-anti-spam-form-bundle/src/Resources/contao/templates/form_c2n_altcha.html5

/**
 * ALTCHA Widget Template - Non-AJAX Support
 */

// Container & Services
$container = \Contao\System::getContainer();
$altchaService = $container->get('con2net.antispam.altcha_service');
$loggingHelper = $container->get('con2net.antispam.logging_helper');

// Debug-Modus prüfen
$debugMode = isset($GLOBALS['TL_CONFIG']['c2n_antispam_debug']) && $GLOBALS['TL_CONFIG']['c2n_antispam_debug'];

// Challenge-Daten aus vorherigem Submit holen (Non-AJAX Mode)
// WICHTIG: $_POST direkt verwenden, da Contao\Input das Feld filtert!
$submittedChallengeDataRaw = isset($_POST[$this->name . '_challenge_data'])
        ? $_POST[$this->name . '_challenge_data']
        : null;

$submittedChallengeData = null;

if ($submittedChallengeDataRaw) {
    // Base64 bereinigen: Nur gültige Base64-Zeichen behalten
    $cleaned = preg_replace('/[^A-Za-z0-9+\/=]/', '', $submittedChallengeDataRaw);

    // Decode
    $decoded = base64_decode($cleaned, true);

    if ($decoded !== false) {
        // JSON bereinigen: Steuerzeichen entfernen
        $decoded = preg_replace('/[\x00-\x1F\x7F]/', '', $decoded);
        $decoded = trim($decoded);

        // JSON validieren
        $test = json_decode($decoded);
        if ($test !== null) {
            $submittedChallengeData = $decoded;

            // Nur im Debug-Modus loggen
            if ($debugMode) {
                $loggingHelper->logInfo(
                        sprintf('ALTCHA: REUSING challenge from previous submit for field "%s" | Length: %d bytes',
                                $this->name,
                                strlen($decoded)
                        ),
                        'Template'
                );
            }
        }
    }
}

$submittedPayload = \Contao\Input::post($this->name);

// Challenge erstellen oder wiederverwenden
if (!empty($submittedChallengeData)) {
    // Challenge-Daten aus Submit wiederverwenden (Non-AJAX Mode)
    $challengeJson = $submittedChallengeData;

    if ($debugMode) {
        $loggingHelper->logInfo(
                sprintf('ALTCHA: REUSING challenge from previous submit for field "%s" | Length: %d bytes',
                        $this->name,
                        strlen($challengeJson)
                ),
                'Template'
        );
    }
} else {
    // Neue Challenge erstellen (erster Aufruf)
    if ($debugMode) {
        $loggingHelper->logInfo(
                sprintf('ALTCHA: CREATING NEW challenge for field "%s"', $this->name),
                'Template'
        );
    }

    try {
        // Parameter aus config.yml holen (mit Fallback auf Defaults)
        $maxNumber = $container->hasParameter('con2net.antispam.altcha.max_number')
                ? (int) $container->getParameter('con2net.antispam.altcha.max_number')
                : 100000;

        $saltLength = $container->hasParameter('con2net.antispam.altcha.salt_length')
                ? (int) $container->getParameter('con2net.antispam.altcha.salt_length')
                : 16;

        $algorithm = $container->hasParameter('con2net.antispam.altcha.algorithm')
                ? (string) $container->getParameter('con2net.antispam.altcha.algorithm')
                : 'SHA-256';

        // Challenge erstellen
        $challenge = $altchaService->createChallenge($maxNumber, $saltLength, $algorithm);

        if (empty($challenge)) {
            throw new \Exception('Challenge creation returned empty array');
        }

        $challengeJson = json_encode($challenge, JSON_THROW_ON_ERROR);

        // Nur im Debug-Modus loggen
        if ($debugMode) {
            $loggingHelper->logInfo(
                    sprintf('ALTCHA: Challenge created successfully | Algorithm: %s | MaxNumber: %d | Salt length: %d',
                            $algorithm,
                            $maxNumber,
                            $saltLength
                    ),
                    'Template'
            );
        }

    } catch (\Exception $e) {
        // Fehler IMMER loggen (auch ohne Debug-Modus)
        $loggingHelper->logError('ALTCHA challenge creation error: ' . $e->getMessage(), 'Template');

        // Fallback: Minimale Challenge
        $challengeJson = json_encode([
                'algorithm' => 'SHA-256',
                'challenge' => '',
                'salt' => '',
                'signature' => ''
        ]);
    }
}

// Challenge JSON für Attribut vorbereiten (nur single quotes escapen)
$challengeJsonForAttr = str_replace("'", "&#39;", $challengeJson);

// Challenge-Hash für Vergleich
$challengeHash = substr(md5($challengeJson), 0, 8);
$challenge = json_decode($challengeJson, true);

if ($debugMode) {
    $loggingHelper->logInfo(
            sprintf('ALTCHA: Challenge for widget | challenge = %s | signature = %s | Hash: %s',
                    substr($challenge['challenge'] ?? 'missing', 0, 20),
                    substr($challenge['signature'] ?? 'missing', 0, 20),
                    $challengeHash
            ),
            'Template'
    );
}
?>
<div class="widget widget-altcha <?= $this->class ?>">
    <?php if ($this->label): ?>
        <label for="ctrl_<?= $this->id ?>" class="invisible">
            <?= $this->label ?>
            <?php if ($this->mandatory): ?>
                <span class="mandatory">*</span>
            <?php endif; ?>
        </label>
    <?php endif; ?>

    <!-- ALTCHA Widget Container -->
    <altcha-widget
            id="altcha_<?= $this->id ?>"
            auto="onload"
            blockspam="true"
            workers="8"
            challengejson='<?= $challengeJsonForAttr ?>'
            hidefooter="false"
            hidelogo="false"
            strings='{"label":"Ich bin kein Roboter","verifying":"Verifizierung läuft...","verified":"Verifiziert","error":"Fehler bei der Verifizierung"}'
            data-widget-id="<?= $this->id ?>"
            data-challenge-hash="<?= $challengeHash ?>">
    </altcha-widget>

    <!-- Hidden Input für Challenge-Response (Payload vom ALTCHA Widget) -->
    <input type="hidden"
           name="<?= $this->name ?>"
           id="ctrl_<?= $this->id ?>"
           value="">

    <!-- Hidden Input für Challenge-Daten (Persistenz für Non-AJAX Mode) -->
    <input type="hidden"
           name="<?= $this->name ?>_challenge_data"
           id="ctrl_<?= $this->id ?>_challenge_data"
           value="<?= base64_encode($challengeJson) ?>"
           data-challenge-hash="<?= $challengeHash ?>">

    <?php if ($this->hasErrors()): ?>
        <p class="error"><?= $this->getErrorAsString() ?></p>
    <?php endif; ?>
</div>